{"version":3,"sources":["main.coffee"],"names":["global","window","this","promise","Promise","require","later","fn","reject","resolve","lresolve","lreject","expanding_all","promises","recurse","args","count","Array","isArray","Error","length","arguments","all","then","apply","condition","callback","next","convert","context","primary_args","prototype","slice","call","resolver","out_args","in_args","push","_","partial","concat","serial","sequence","first_result","call_next","results","cb","v","each","result","stack","add_to_stack","isFunction","isObject"],"mappings":"CAAA,WAAAA,OAAA,mBAAA,SAAAA,QAAA,mBAAA,SAAAC,QAAAC,IAAA,IAAAC,EACAA,GAAUH,OAAOI,SAAWC,QAAQ,YACpCL,OAAOI,QAAUD,EASjBC,QAAQE,MAAQ,SAACC,GAChB,GAAAC,GAAAC,QAAAA,GAAU,OACVD,EAAS,OACTL,EAAc,GAAAC,SAAQ,SAACM,EAAUC,GAGhC,GAFAF,EAAUC,EACVF,EAASG,EACNJ,QACFA,GAAGE,EAASD,KAEdL,EAAQM,QAAUA,EAClBN,EAAQK,OAASA,EACjBL,GASDC,QAAQQ,cAAgB,SAACC,SACpB,IAAAT,SAAQ,SAACK,EAASD,GACrB,GAAAM,UAAAA,EAAU,SAACD,EAAUJ,GACpB,GAAAM,GAAAC,CACA,IADAD,EAAO,aACGF,eAA0BI,MAAMC,QAAQL,GACjD,KAAU,IAAAM,OAAM,oCACjB,OAAsB,KAAnBN,EAASO,OACJX,KACRM,EAAOM,UACPL,EAAQH,EAASO,OACjBhB,QAAQkB,IAAIT,GAAUU,KAAK,WAC1B,MAAGV,GAASO,SAAUJ,EACdF,EAAQU,MAAMtB,KAAMa,GAE5BN,SAEMI,EAAUJ,MAGpBL,QAAO,MAAS,SAACqB,EAAWC,GAC3B,GAAAC,SAAAA,GAAO,SAACF,EAAWC,GAClB,MAAGD,KACFC,IAAWH,KAAK,iBAAKI,GAAKF,EAAWC,KAErCtB,QAAQK,WACVL,QAAQK,QAAQkB,EAAKF,EAAWC,KAGjCtB,QAAQwB,QAAU,SAACF,EAAUG,SAC5B,YACC,GAAAC,SAAAA,GAAeb,MAAMc,UAAUC,MAAMC,KAAKZ,WACtC,GAAAjB,SAAQ,SAACK,GACZ,GAAAyB,SAAAA,GAAW,iBAEVzB,IAAS0B,SAAUd,UAAWe,QAASN,EAAcD,QAASA,KAE/DC,EAAaO,KAAKH,GAClBI,EAAEC,QAAQf,MAAMc,GAAGZ,GAAUc,OAAOV,UAyBvC1B,QAAQqC,OAAS,SAACC,EAAUC,GAC3B,GAAAC,GAAAC,QAAAA,GAA0B,SAAhBF,IAA8BA,OAExCC,EAAY,SAACE,SACZ1C,SAAQK,QAAQqC,EAAGD,IAAUtB,KAAK,SAACwB,SAClCF,GAAQR,KAAKU,MAEf3C,QAAQ4C,KAAKN,EAAUE,GAAWrB,KAAK,iBACtCsB,MAYFzC,QAAQsC,SAAW,SAACA,EAAUC,GAC7B,GAAAC,GAAAK,QAAAA,GAASN,EACTC,EAAY,SAACE,SACZ1C,SAAQK,QAAQqC,EAAGG,IAAS1B,KAAK,SAACwB,SACjCE,GAASF,KAEX3C,QAAQ4C,KAAKN,EAAUE,GAAWrB,KAAK,iBACtC0B,MAsBF7C,QAAQ8C,MAAQ,SAAC3C,GAChB,GAAA4C,SAAAA,GAAe,SAAC5C,GACf,GAAI+B,EAAEc,WAAW7C,SAMhB4C,GAAahD,QAAUgD,EAAahD,QAAQoB,KAAKhB,EALjD,IAAG+B,EAAEe,SAAS9C,IAAOA,EAAGgB,WACvB4B,GAAahD,QAAUgD,EAAahD,QAAQoB,KAAK,iBAAKhB,IAEtD,MAAU,IAAAY,OAAM,uCAInBgC,EAAahD,QAAUC,QAAQK,UAG5BF,GACF4C,EAAa5C,GAEd4C","file":"main.js","sourcesContent":["`global= (typeof(global) != 'undefined' && global)  || (typeof(window) != 'undefined' && window) || this`\npromise = global.Promise || require('bluebird')\nglobal.Promise = promise\n\n\n#/return a promise that has a resolve and reject method (such that it can resolve itself)\n\n###*\n@param\tfn\t<optional, fn(resolve, reject)>\n###\n\nPromise.later = (fn) ->\n\tresolve = undefined\n\treject = undefined\n\tpromise = new Promise((lresolve, lreject) ->\n\t\tresolve = lresolve\n\t\treject = lreject\n\t\tif fn\n\t\t\tfn resolve, reject\t)\n\n\tpromise.resolve = resolve\n\tpromise.reject = reject\n\tpromise\n\n#/ like Promise.all, but handles expanding array of promises\n\n###*\n@note\tif a promise is added after the previous array was already considered resolved, it will not un-resolve the promise returned by this function\n@param\t[<promise>,...]\n###\n\nPromise.expanding_all = (promises) ->\n\tnew Promise((resolve, reject) ->\n\t\trecurse = (promises, resolve) ->\n\t\t\targs = undefined\n\t\t\tif typeof promises != typeof {} or !Array.isArray(promises)\n\t\t\t\tthrow new Error('Promises not an array of promises')\n\t\t\tif promises.length == 0\n\t\t\t\treturn resolve()\n\t\t\targs = arguments\n\t\t\tcount = promises.length\n\t\t\tPromise.all(promises).then ->\n\t\t\t\tif promises.length != count\n\t\t\t\t\treturn recurse.apply this, args\n\n\t\t\t\tresolve()\n\n\t\trecurse promises, resolve\n\t)\n\nPromise.while = (condition, callback)->\n\tnext = (condition, callback)->\n\t\tif condition() # while condition\n\t\t\tcallback().then ()-> next(condition, callback)\n\t\telse\n\t\t\tPromise.resolve()\n\tPromise.resolve(next(condition, callback))\n\n# See README\nPromise.convert = (callback, context)->\n\t()->\n\t\tprimary_args = Array.prototype.slice.call(arguments)\n\t\tnew Promise (resolve)->\n\t\t\tresolver = ()->\n\t\t\t\t# \"return\" kept for backwards compatibility (phantomjs)\n\t\t\t\tresolve({out_args: arguments, in_args: primary_args, context: context}) #< more is more\n\n\t\t\tprimary_args.push resolver\n\t\t\t_.partial.apply(_,[callback].concat primary_args)()\n\n\t\t\t#callback.bind_args(primary_args)()\n\n\n###\nCall a series of functions, sequentially, while building, passing, and returning the array of individual function returns\n\t.serial([fn1,fn2,fn3], r0)\n\t\tfn1([r0]) -> r1\n\t\tfn2([r0, r1]) -> r2\n\t\tfn3([r0, r1, r2]) -> r3\n\t\treturn [r0, r1, r2, r3]\n\nAllows for non-promise-returning functions\n\nEx\n\tsequence = [\n\t\t()-> Promise.delay(1000).then(()->'bob1'),\n\t\t()-> Promise.delay(10).then(()->'bob2'),\n\t\t()-> Promise.delay(10).then(()->'bob3')\n\t\t]\n\n\tPromise.serial(sequence).then (r)->\n\t\tc arguments\n###\nPromise.serial = (sequence, first_result)->\n\tresults = first_result != undefined && [first_result] || []\n\n\tcall_next = (cb)->\n\t\tPromise.resolve(cb(results)).then (v)-> # dig, to allow non-promise fn's to be used\n\t\t\tresults.push v\n\n\tPromise.each(sequence, call_next).then ()->\n\t\tresults # return the results to the outside .then, if any\n\n\n###\nCall a series of functions, sequentially, while passing-thru the return, finally resolving with final fn return\n\t.serial([fn1,fn2,fn3], r0)\n\t\tfn1(r0) -> r1\n\t\tfn2(r1) -> r2\n\t\tfn3(r2) -> r3\n\t\treturn r3\n\n###\nPromise.sequence = (sequence, first_result)->\n\tresult = first_result\n\tcall_next = (cb)->\n\t\tPromise.resolve(cb(result)).then (v)->\n\t\t\tresult = v\n\n\tPromise.each(sequence, call_next).then ()->\n\t\tresult # return the result of last fn\n\n\n### Intended to replace the attached chain\nGoing from:\n\tbill().then(bob).then(sue)\nto\n\tstack = Promise.stack(bill)\n\tstack bob\n\tstack sue\n\n\nEx\n\t# linear execution of looped promises.  If linear execution isn't desired, use Promise.all\n\tfor i in [0...5]\n\t\tstack associate_product\n\tstack ()->\n\t\t# code that happens after the for loop\n\n@NOTE\tcan access underlying promise with `stack.promise`\n@NOTE\tcan stack either fn or promise\n###\nPromise.stack = (fn)->\n\tadd_to_stack = (fn)->\n\t\tif !_.isFunction fn\n\t\t\tif _.isObject(fn) && fn.then\n\t\t\t\tadd_to_stack.promise = add_to_stack.promise.then(()-> fn)\n\t\t\telse\n\t\t\t\tthrow new Error('Stack addition not a fn or promise')\n\t\telse\n\t\t\tadd_to_stack.promise = add_to_stack.promise.then(fn)\n\n\tadd_to_stack.promise = Promise.resolve()\n\n\t# if maker is called with a fn, assume initialiser\n\tif fn\n\t\tadd_to_stack(fn)\n\n\tadd_to_stack\n"],"sourceRoot":"/source/"}